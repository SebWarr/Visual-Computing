<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="3D Brush # Introducción # En esta implementación de el Pincel en 3D (3D Brush), se utiliza un control remoto de un Nintendo Wii (Wiimote) para el control del dibujo y movimiento del plano. Esto se suma al uso de TreeGL y EasyCAM.
El Control Remoto # El Wiimote es el control remoto de la Consola Nintendo Wii (2006 - 2017); utiliza tecnología Bluetooth para la conexión con el Wii y con otros dispositivos."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="3D Brush # Introducción # En esta implementación de el Pincel en 3D (3D Brush), se utiliza un control remoto de un Nintendo Wii (Wiimote) para el control del dibujo y movimiento del plano. Esto se suma al uso de TreeGL y EasyCAM.
El Control Remoto # El Wiimote es el control remoto de la Consola Nintendo Wii (2006 - 2017); utiliza tecnología Bluetooth para la conexión con el Wii y con otros dispositivos."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcomputing.github.io/Visual-Computing/docs/shortcodes/talleres/3D-brush/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-05-26T04:40:04-05:00"><title>3 D Brush | Showcase Template</title><link rel=manifest href=/Visual-Computing/manifest.json><link rel=icon href=/Visual-Computing/favicon.png type=image/x-icon><link rel=stylesheet href=/Visual-Computing/book.min.ab46de3e725a6415339a37bba23a0067534a37289b063c9f8d011515a63097a8.css integrity="sha256-q0bePnJaZBUzmje7ojoAZ1NKNyibBjyfjQEVFaYwl6g=" crossorigin=anonymous><script defer src=/Visual-Computing/flexsearch.min.js></script>
<script defer src=/Visual-Computing/en.search.min.e5506e4436f247366c9ec62fd6e0eb4d38eb0ef8f14a1cf5fc4c0cd38723cfb4.js integrity="sha256-5VBuRDbyRzZsnsYv1uDrTTjrDvjxShz1/EwM04cjz7Q=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/Visual-Computing/><span>Showcase Template</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Shortcodes</span><ul><li><a href=/Visual-Computing/docs/shortcodes/buttons/>Buttons</a></li><li><a href=/Visual-Computing/docs/shortcodes/columns/>Columns</a></li><li><a href=/Visual-Computing/docs/shortcodes/details/>Details</a></li><li><a href=/Visual-Computing/docs/shortcodes/expand/>Expand</a></li><li><a href=/Visual-Computing/docs/shortcodes/hints/>Hints</a></li><li><a href=/Visual-Computing/docs/shortcodes/tabs/>Tabs</a></li><li><input type=checkbox id=section-b799dcc3c90fdccf6fcb76e744e8a2c0 class=toggle checked>
<label for=section-b799dcc3c90fdccf6fcb76e744e8a2c0 class="flex justify-between"><a href=/Visual-Computing/docs/shortcodes/talleres/>Talleres</a></label><ul><li><a href=/Visual-Computing/docs/shortcodes/talleres/3D-brush/ class=active>3 D Brush</a></li><li><a href=/Visual-Computing/docs/shortcodes/talleres/rasterization/>Rasterization</a></li><li><a href=/Visual-Computing/docs/shortcodes/talleres/shaders_excercises/>Shaders Excercises</a></li><li><a href=/Visual-Computing/docs/shortcodes/talleres/watercolor/>Watercolor</a></li></ul></li></ul></li></ul><ul><li><a href=/Visual-Computing/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/Visual-Computing/svg/menu.svg class=book-icon alt=Menu></label>
<strong>3 D Brush</strong>
<label for=toc-control><img src=/Visual-Computing/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#3d-brush>3D Brush</a><ul><li><a href=#introducción>Introducción</a></li><li><a href=#el-control-remoto>El Control Remoto</a><ul><li><a href=#la-conexión-wiimote-for-the-web>La conexión; Wiimote for the Web</a></li><li><a href=#integración>Integración</a></li></ul></li><li><a href=#resultados--implementación>Resultados / Implementación.</a></li><li><a href=#apreciaciones-y-conclusiones>Apreciaciones y Conclusiones</a></li><li><a href=#referencias-y-consulta-avanzada>Referencias y consulta avanzada.</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=3d-brush>3D Brush
<a class=anchor href=#3d-brush>#</a></h1><h2 id=introducción>Introducción
<a class=anchor href=#introducci%c3%b3n>#</a></h2><p>En esta implementación de el Pincel en 3D (3D Brush), se utiliza un control remoto de un Nintendo Wii (Wiimote) para el control del dibujo y movimiento del plano. Esto se suma al uso de TreeGL y EasyCAM.</p><h2 id=el-control-remoto>El Control Remoto
<a class=anchor href=#el-control-remoto>#</a></h2><p><img src=https://i.blogs.es/8ba955/fundawii/450_1000.jpg alt=3dbrush1></p><p>El Wiimote es el control remoto de la Consola Nintendo Wii (2006 - 2017); utiliza tecnología Bluetooth para la conexión con el Wii y con otros dispositivos. Está construido sobre el SOC Broadcom BCM2042. A pesar de utilizar las interfaces estandar USB HID no utiliza los descriptores ni tipos de datos estandar por lo que son necesarios drivers o programas especializados para la conexión.</p><h3 id=la-conexión-wiimote-for-the-web>La conexión; Wiimote for the Web
<a class=anchor href=#la-conexi%c3%b3n-wiimote-for-the-web>#</a></h3><p>En esta oportunidad se ha optado por utilizar la librería WiiMote for the Web, que se basa en la tecnología WebHID. WebHID aún se considera una tecnología de caracter experimental por lo que es necesario habilitarla para el uso en los navegadores soportados (basados en Chromium).</p><p>La librería combina el uso de WebHID y JavaScript para generar una interface que permite hacer uso de prácticamente todas las funcionalidades del WiiMote (bluetooth, botones, LEDs, vibración, infrarrojo, etc.).</p><h3 id=integración>Integración
<a class=anchor href=#integraci%c3%b3n>#</a></h3><p>La librería nos entregará un arreglo con todos los botones y en caso de que alguno de ellos sea oprimido el elemento cambiará del valor &ldquo;false&rdquo; al valor &ldquo;true&rdquo;. Adicionalmente, también nos entregará los datos del acelerómetro integrado del control y funcionalidades para activar o desactivar los LED y el vibrador interno.</p><p>Es de resaltar que el Wiimote es un senson de infrarrojo en si mismo y la barra inicialmente incluida en los Wii únicamente cumplia la funcionalidad de contar con infrarrojos para que el control la viera.</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Nintendo_Wii_Sensor_Bar.jpg/640px-Nintendo_Wii_Sensor_Bar.jpg alt=3dbrush2></p><p>El principal reto en la implementación fue la integración de la librería con la interface de p5js y la normalización de los valores de algunos inputs para obtener la funcionalidad deseada.</p><h2 id=resultados--implementación>Resultados / Implementación.
<a class=anchor href=#resultados--implementaci%c3%b3n>#</a></h2><iframe frameborder=0 style=width:700px;height:600px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script type=module src=/Visual-Computing/sketches/index.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script>             
            <script src=/Visual-Computing/sketches/shaders/uv.js></script>
            <script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
             <script src=https://cdn.jsdelivr.net/gh/freshfork/p5.EasyCam@1.2.1/p5.easycam.js></script> 
            
            
            
            <button id='controlId' style='float: right' hidden>Wiimote</button>
            <button id='led' style='float: right' hidden></button>
            <button id='led1' style='float: right' hidden></button>
            <button id='led2' style='float: right' hidden></button>
            <br>
            <br>
            <button id='controlIdHome' style='float: right' onclick='myfunction()' hidden>Home</button>
            
            <br>
            <script>
              var info;
              var accelero;
              
  
// Goal in the 3d Brush is double, to implement:
// 1. a gesture parser to deal with depth, i.e.,
// replace the depth slider with something really
// meaningful. You may use a 3d sensor hardware
// such as: https://en.wikipedia.org/wiki/Leap_Motion
// or machine learning software to parse hand (or
// body) gestures from a (video) / image, such as:
// https://ml5js.org/
// 2. other brushes to stylize the 3d brush, taking
// into account its shape and alpha channel, gesture
// speed, etc.

// Brush WiiMote
let control;

// Brush controls

let color;
let depth;
let brush;
let selectBrush;

let wiimoteX = 300;
let wiimoteY = 225;

let easycam;
let state;

let escorzo;
let points;
let record;
let rotate;
let accelerometro;

function resetPosition(){
  state = {
    distance: 250,           // scalar
    center: [0, 0, 0],       // vector
    rotation: [0, 0, 0, 1],  // quaternion
  };
  easycam.state_reset = state;   // state to use on reset (double-click/tap)
  easycam.setState(state, 500); // now animate to that state
  escorzo = true;
  perspective();
}

function setup() {
  
  createCanvas(600, 450, WEBGL);
  // easycam stuff
  let state = {
    distance: 250,           // scalar
    center: [0, 0, 0],       // vector
    rotation: [0, 0, 0, 1],  // quaternion
  };
  easycam = createEasyCam();
  easycam.state_reset = state;   // state to use on reset (double-click/tap)
  easycam.setState(state, 2000); // now animate to that state
  escorzo = true;
  perspective();

  // brush stuff
  points = [];
  depth = createSlider(0, 1, 0.01, 0.01);
  depth.id('slider');
  depth.value(0.01);
  depth.position(10, 10);
  depth.style('width', '580px');
  // slider
  depth.hide();
  color = '#ffa500';
  
  
}

function draw() {
  if(selectBrush){brush = cubeBrush;}else{brush = sphereBrush;}
  captureWiiMote();
  update();
  background('#343a40');
  push();
  strokeWeight(1.5);
  stroke('white');
  grid({ dotted: false });
  pop();
  axes();
  for (const point of points) {
    push();
    translate(point.worldPosition);
    brush(point);
    pop();
  }
}

function captureWiiMote(){
  if(info){
  if(info.HOME === true){
    resetPosition();
    
  }
  if(info.HOME === true && info.MINUS === true){
    points = [];
  }
  if(info.ONE === true){
    record = !record;
    led.click();
    //led(1);
  }
  if(info.MINUS === true && info.PLUS === true){
    accelerometro = !accelerometro;
    led2.click();
  }
  if(info.TWO === true){
    selectBrush = !selectBrush;
    led1.click();
  }
  if(record){
  
    if(info.DPAD_RIGHT === true){
       wiimoteX += 1;
      }
      if(info.DPAD_LEFT === true){
        wiimoteX -= 1;
      }
      if(info.DPAD_UP === true){
        wiimoteY -= 1;
      }
      if(info.DPAD_DOWN === true){
        wiimoteY += 1;
      }
      if(info.B === true && info.PLUS === true){
        var valor =  parseFloat(document.getElementById('slider').value);
        document.getElementById(&#34;slider&#34;).value = valor - 0.01;
      }
      if(info.B === true && info.MINUS === true){
        var valor =  parseFloat(document.getElementById('slider').value);
        document.getElementById(&#34;slider&#34;).value = valor + 0.01;
      }
      let dx = abs(wiimoteX);
      let dy = abs(wiimoteY);
      speed = constrain((dx + dy) / (2 * (width - height)), 0, 1);

        points.push({
          worldPosition: treeLocation([wiimoteX, wiimoteY, depth.value()], { from: 'SCREEN', to: 'WORLD' }),
          color: '#ffa500',
          speed: speed
        });   
    }
    if(info.A === true){
    led1.click();
    if(info.DPAD_RIGHT === true){
       easycam.rotateY(0.01);
      }
      if(info.DPAD_LEFT === true){
        easycam.rotateY(-0.01);
      }
      if(info.DPAD_UP === true){
        easycam.rotateX(0.01);
        
      }
      if(info.DPAD_DOWN === true){
        easycam.rotateX(-0.01);
      }
      if(info.MINUS === true){
        easycam.zoom(+1);
      }
      if(info.PLUS === true){
        easycam.zoom(-1);
      }
      }
    
    }

    if(accelerometro){
      console.log(accelero);
      easycam.rotateY(accelero.x);
      easycam.rotateX(accelero.y);
      //easycam.zoom(accelero.z);
      console.log(&#34;activado&#34;);
    }
}


function update() {
  let dx = abs(mouseX);
  let dy = abs(mouseY);
  speed = constrain((dx + dy) / (2 * (width - height)), 0, 1);
  if (record) {
    points.push({
      worldPosition: treeLocation([mouseX, mouseY, depth.value()], { from: 'SCREEN', to: 'WORLD' }),
      color: '#ffa500',
      speed: speed
    });
  }
}

function sphereBrush(point) {
  push();
  noStroke();
  // TODO parameterize sphere radius and / or
  // alpha channel according to gesture speed
  fill(point.color);
  sphere(1);
  pop();
}

function cubeBrush(point) {
  push();
  noStroke();
  // TODO parameterize sphere radius and / or
  // alpha channel according to gesture speed
  fill(point.color);
  box(1);
  pop();
}

function keyPressed() {
  if (key === 'r') {
    record = !record;
  }
  if (key === 'p') {
    escorzo = !escorzo;
    escorzo ? perspective() : ortho();
  }
  if (key == 'c') {
    points = [];
  }
}

function mouseWheel(event) {
  //comment to enable page scrolling
  return false;
}




              function myfunction() {
                resetPosition();
              }

            </script>
            
          </head>
          <body style='background-color:#343a40;'>
          </body>
        </html>
      "></iframe><h2 id=apreciaciones-y-conclusiones>Apreciaciones y Conclusiones
<a class=anchor href=#apreciaciones-y-conclusiones>#</a></h2><p>Lo más interesante fue ver la funcionalidad que aún presenta un dispositivo tan antiguo para los estandares de hoy como lo es el Wiimote; apesar de tener más de 15 años en el mercado, cuenta con funcionalidades bastante especiales que en su momento le hicieron un dispositivo único y posicionaron a la Wii consola más vendida en la historia de Nintendo.</p><p>Muy importantes tambien son las funcionalidades que aún puede tener un dispositivo como este; el sensor de infrarrojos abre todo tipo de posibilidades para la interacción con espacios en 3D. Esta es una funcionalidad que podría ser implementada en una nueva iteración.</p><p>Es importante mencionar que la librería p5.EasyCam contó con una gran facilidad de utilización y fue de facil implementación. A pesar de eso, mostró lo poderosa que puede llegar a ser en el manejo de espacios 3D al contar con funcionalidades como sobreo e iluminación avanzada.</p><p>Finalmente, se quiere mencionar el uso de una tecnología experimental como lo es WebHID; cuando esta tecnología logre ser adoptada de manera más amplia se abrirá la puerta a que los navegadores puedan acceder directamente a dispositivos de hardware (contoles, simuladores, dispositivos médicos, etc) sin la necesidad de drivers o modificaciones por parte de los usuarios. Desafortunadamente la única implementación actual de esta tecnología se encuentra en los navegadores basados en Chromium.</p><h2 id=referencias-y-consulta-avanzada>Referencias y consulta avanzada.
<a class=anchor href=#referencias-y-consulta-avanzada>#</a></h2><ul><li><a href=https://github.com/PicchiKevin/wiimote-webhid>Kevin Picchi, Wiimote for the Web</a></li><li><a href=https://wicg.github.io/webhid/>W3C Community Group Draft Report - WebHID API (Marzo de 2022)</a></li><li><a href=https://p5js.org/es/reference/>p5.js - Referencia</a></li><li><a href=https://github.com/freshfork/p5.EasyCam>James William Dunn - Referencia p5.EasyCam</a></li><li><a href=https://gohugo.io/functions/>Hugo References</a></li><li><a href=https://es.wikipedia.org/wiki/Wiimote>Wiimote - Wikipedia, la enciclopedia libre</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/00ff5360b60b843c01b9c0b369dd5d22bc347b4d title='Last modified by Cesar David Pineda Osorio | May 26, 2022' target=_blank rel=noopener><img src=/Visual-Computing/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 26, 2022</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#3d-brush>3D Brush</a><ul><li><a href=#introducción>Introducción</a></li><li><a href=#el-control-remoto>El Control Remoto</a><ul><li><a href=#la-conexión-wiimote-for-the-web>La conexión; Wiimote for the Web</a></li><li><a href=#integración>Integración</a></li></ul></li><li><a href=#resultados--implementación>Resultados / Implementación.</a></li><li><a href=#apreciaciones-y-conclusiones>Apreciaciones y Conclusiones</a></li><li><a href=#referencias-y-consulta-avanzada>Referencias y consulta avanzada.</a></li></ul></li></ul></nav></div></aside></main></body></html>